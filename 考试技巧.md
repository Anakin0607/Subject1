# 5. 骗分
考试如果遇到实在解不出来的部分，我们不能心甘情愿的就放弃，能争取还是需要争取一下的，骗分一定切记，不能贪多，因为反正我不会，拿一分我赚一分。
## 5.1 单一状况解
### 5.1.1 均匀分布
在有些题目中，输出的答案种类非常少,如:
[165.比较版本号](https://leetcode.cn/problems/compare-version-numbers/description/): 只有三种答案，1，-1和0
[495.重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/description/):只有两种情况，true和false
对于这种类型的题目，如果实在不会做，那就选一个答案输出，如165就可以这样提交：
```C
#include<stdio.h>
int main(){
    printf("1");
    return 0;
}
```
至于输出哪个答案，可以根据题意判断一下，出现哪个答案的概率更大，如165题里面，1和-1概率好像差不多，0概率应该会小一点，所以输出1或者-1显然更靠谱一点。
至于495，也看不出来，那就随便选一个输出好咯。如果真的相信自己的运气，也可以这样：
``` C
#include<stdio.h>
#include<stdlib.h>
int main(){
    strand(time(NULL));
    int ans = rand() % 2;//生成随机数，对2取模，即随机一个数，看他是奇数还是偶数
    if(ans) printf("true");
    else printf("false");
    return 0;
}
```
随机一个数，奇数输出true偶数输出false，相比选一个答案稳定得到一半的分数，随机数可能0分也可能100分，听天由命

### 5.1.2 无解或特殊解
还有些题会有无解或者特殊解，如：
(1) [1405.最长快乐字符串](https://leetcode.cn/problems/longest-happy-string/description/):如果不存在，返回空字符串""
对于这种类型的，看不懂题都无所谓，无脑输出一个空，至少不会零分
类似的还有**真题的34.可漫游服务区**：如果不存在输出empty

(2) [1366.通过投票对团队排名](https://leetcode.cn/problems/rank-teams-by-votes/description/)：
对于这种类型的，输入数据处理起来比较复杂，题面也比较晦涩，在读懂题的前提下观察一下数据特征，看看有没有一些数据可以无脑出答案，针对这些数据编写输出骗分即可
如示例5，可能只有一支队伍，那答案只有一种可能，直接输出这个队名就行
```C
char* rankTeams(char** votes, int votesSize){
    char* ans = (char*)malloc(sizeof(char)*2);//要求返回一个字符串，因此需要分配两个char的空间，一个给队名一个给\0
    ans[0] = votes[0][0]; 
    ans[1] = '\0';
    return ans;
}
```

(3) 真题36.比特反转
如第二个样例，可能所有的都一样或者只有一个不一样的，答案就是整个序列的长度
```C
#include<stdio.h>
int main(){
    int n;
    scanf("%d", &n);
    //其他的不用读，反正只需要序列长度
    printf("%d", n);
    return 0;
}
```
这种的不要贪多，如果打算骗分，一定就只输出一种，不要想着多骗，找一种最稳当的输出了就行。如果真的想处理这个数据，不如仔细再思考一下，正解就出来了，这种类型的题骗分的中心思想就是，不处理数据，直接得出特殊情况的答案。


## 5.2 打表
还有一类的题，输入数据非常简单，题面也很好读懂，并且通过手算可以得出一些数据较小的答案，但用代码实现起来比较复杂，这种情况可以先手算，然后把答案根据数据输出出来。
### 5.2.1 伐木工（机试200分题目）

**题目描述**
> 一根x米长的树木，伐木工切割成不同长度的木材进行交易，交易价格为每根木头长度的乘积，规定切割后每根木头的长度为正整数，也可以不切割，直接拿整根数目进行交易，请问伐木工如何更少的切割，才能使收益最大化?
**输入描述：** 木材长度x(x<=50)
**输出描述:** 切割方案，以空格分割，升序排列
**样例输入：** 10
**样例输出：** 3 3 4

看完题目之后，这好像短时间内不好写，但是观察一下，确实有白送的分
显然长度为1，2，3都不用切割，4可以切成2*2也可以不切，因为要求尽可能少切，所以4也不用切
5切成2和3，6切成3和3，7切成3和4
8好像就不太好算了，是2，3，3，不算那么白送了，此时不要贪多，如果还有别的题没做，那就先写到这儿，然后看其他题
``` C
switch(x){
    case 1:{
        printf("1");
        break;
    }
    case 2:{
        printf("2");
        break;
    }
 
    case 3:{
        printf("3");
        break;
    }
    case 4:{
        printf("4");
        break;
    }
    case 5:{
        printf("5");
        break;
    }
    case 6:{
        printf("6");
        break;
    }
    case 7:{
        printf("7");
        break;
    }
}
```
## 5.3 找规律